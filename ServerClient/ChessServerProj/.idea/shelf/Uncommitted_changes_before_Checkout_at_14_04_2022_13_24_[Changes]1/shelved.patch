Index: src/ver14/Server.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ver14;\r\n\r\nimport ver14.DB.DB;\r\nimport ver14.Model.minimax.Minimax;\r\nimport ver14.SharedClasses.Game.GameSettings;\r\nimport ver14.SharedClasses.Game.SavedGames.CreatedGame;\r\nimport ver14.SharedClasses.Game.SavedGames.GameInfo;\r\nimport ver14.SharedClasses.Game.SavedGames.UnfinishedGame;\r\nimport ver14.SharedClasses.IDsGenerator;\r\nimport ver14.SharedClasses.LoginInfo;\r\nimport ver14.SharedClasses.LoginType;\r\nimport ver14.SharedClasses.RegEx;\r\nimport ver14.SharedClasses.Sync.SyncableItem;\r\nimport ver14.SharedClasses.Sync.SyncedItems;\r\nimport ver14.SharedClasses.Sync.SyncedListType;\r\nimport ver14.SharedClasses.Threads.ErrorHandling.*;\r\nimport ver14.SharedClasses.Threads.ThreadsManager;\r\nimport ver14.SharedClasses.Utils.ArgsUtil;\r\nimport ver14.SharedClasses.Utils.StrUtils;\r\nimport ver14.SharedClasses.messages.Message;\r\nimport ver14.SharedClasses.messages.MessageType;\r\nimport ver14.SharedClasses.networking.AppSocket;\r\nimport ver14.SharedClasses.ui.MyJButton;\r\nimport ver14.SharedClasses.ui.windows.MyJFrame;\r\nimport ver14.game.GameSession;\r\nimport ver14.players.Player;\r\nimport ver14.players.PlayerAI.PlayerAI;\r\nimport ver14.players.PlayerNet.PlayerNet;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.awt.event.KeyAdapter;\r\nimport java.awt.event.KeyEvent;\r\nimport java.net.InetAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n\r\n/**\r\n * The type Server.\r\n */\r\npublic class Server implements ErrorContext, EnvManager {\r\n    /**\r\n     * The constant SERVER_WIN_TITLE.\r\n     */\r\n    public static final String SERVER_WIN_TITLE = \"Chat Server\";\r\n    /**\r\n     * The constant SERVER_LOG_FONT.\r\n     */\r\n    public static final Font SERVER_LOG_FONT = new Font(\"Consolas\", Font.PLAIN, 16); // Font.MONOSPACED\r\n    // constants\r\n    private static final int SERVER_DEFAULT_PORT = 1234;\r\n    private static final Dimension SERVER_WIN_SIZE = new Dimension(580, 400);\r\n    private static final Color SERVER_LOG_BGCOLOR = Color.BLACK;\r\n    private static final Color SERVER_LOG_FGCOLOR = Color.GREEN;\r\n    private final static IDsGenerator gameIDGenerator;\r\n    private static int START_AT_PORT = -1;\r\n\r\n    static {\r\n\r\n        gameIDGenerator = new IDsGenerator() {\r\n            @Override\r\n            public boolean canUseId(String id) {\r\n                if (!super.canUseId(id))\r\n                    return false;\r\n                return !DB.isGameIdExists(id);\r\n            }\r\n        };\r\n    }\r\n\r\n    private SyncedItems<PlayerNet> players;\r\n    private SyncedItems<GameSession> gameSessions;\r\n    private SyncedItems<GameInfo> gamePool;\r\n    private ArrayList<SyncedItems<?>> syncedLists;\r\n    private MyJFrame frmWin;\r\n    private JTextArea areaLog;\r\n    private String serverIP;\r\n    private int serverPort;\r\n    private boolean serverSetupOK, serverRunOK;\r\n    private MyServerSocket serverSocket;\r\n    private int autoChatterID;\r\n\r\n    /**\r\n     * Constructor for ChatServer.\r\n     */\r\n    public Server() {\r\n        ErrorManager.setEnvManager(this);\r\n        ThreadsManager.handleErrors(() -> {\r\n            createServerGUI();\r\n            setupServer();\r\n        });\r\n\r\n    }\r\n\r\n    // create server GUI\r\n    private void createServerGUI() {\r\n        frmWin = new MyJFrame() {{\r\n            setSize(SERVER_WIN_SIZE);\r\n            setTitle(SERVER_WIN_TITLE);\r\n            setOnExit(Server.this::exitServer);\r\n//            setAlwaysOnTop(true);\r\n        }};\r\n        JPanel bottomPnl = new JPanel();\r\n        MyJButton connectedUsersBtn = new MyJButton(\"Connected Users\", () -> {\r\n            log(\"Connected Users:\");\r\n            players.forEachItem(plr -> {\r\n                log(StrUtils.dontCapWord(plr.getUsername()));\r\n            });\r\n        });\r\n        MyJButton gameSessionsBtn = new MyJButton(\"Game Sessions\", () -> {\r\n            log(\"Game Sessions:\");\r\n            gameSessions.forEachItem(session -> {\r\n                log(session.sessionsDesc());\r\n            });\r\n        });\r\n        MyJButton usersDetailsBtn = new MyJButton(\"Users Details\", () -> {\r\n            log(\"Users Details:\");\r\n            DB.getAllUserDetails().forEach(userDetails -> log(StrUtils.dontCapFull(userDetails.toString())));\r\n        });\r\n\r\n        bottomPnl.add(connectedUsersBtn);\r\n        bottomPnl.add(gameSessionsBtn);\r\n        bottomPnl.add(usersDetailsBtn);\r\n        // create displayArea\r\n        areaLog = new JTextArea() {{\r\n            setEditable(false);\r\n            setFont(SERVER_LOG_FONT);\r\n            setMargin(new Insets(5, 5, 5, 5));\r\n            setBackground(SERVER_LOG_BGCOLOR);\r\n            setForeground(SERVER_LOG_FGCOLOR);\r\n            addKeyListener(new KeyAdapter() {\r\n                @Override\r\n                public void keyPressed(KeyEvent e) {\r\n                    if (e.getKeyCode() == KeyEvent.VK_PAGE_UP) {\r\n                        Font font = areaLog.getFont();\r\n                        Font biggerFont = new Font(font.getFamily(), font.getStyle(), font.getSize() + 1);\r\n                        areaLog.setFont(biggerFont);\r\n                    }\r\n                    if (e.getKeyCode() == KeyEvent.VK_PAGE_DOWN) {\r\n                        Font font = areaLog.getFont();\r\n                        Font smallerFont = new Font(font.getFamily(), font.getStyle(), font.getSize() - 1);\r\n                        areaLog.setFont(smallerFont);\r\n                    }\r\n                }\r\n            });\r\n        }};\r\n        // panel for send message\r\n        frmWin.add(new JScrollPane(areaLog), BorderLayout.CENTER);\r\n        frmWin.add(bottomPnl, BorderLayout.SOUTH);\r\n\r\n        // show window\r\n        frmWin.setLocationRelativeTo(null);\r\n        SwingUtilities.invokeLater(() -> {\r\n            frmWin.setVisible(true);\r\n        });\r\n    }\r\n\r\n    // setup Server Address(IP&Port) and create the ServerSocket\r\n    private void setupServer() {\r\n        try {\r\n            autoChatterID = 0;\r\n            players = new SyncedItems<>(SyncedListType.CONNECTED_USERS, this::syncedListUpdated);\r\n            gamePool = new SyncedItems<>(SyncedListType.JOINABLE_GAMES, this::syncedListUpdated);\r\n            gameSessions = new SyncedItems<>(SyncedListType.ONGOING_GAMES, this::syncedListUpdated);\r\n\r\n            this.syncedLists = new ArrayList<>() {{\r\n                add(players);\r\n                add(gamePool);\r\n                add(gameSessions);\r\n            }};\r\n            serverPort = START_AT_PORT;\r\n            serverIP = InetAddress.getLocalHost().getHostAddress(); // get Computer IP\r\n\r\n            if (serverPort == -1) {\r\n                String port = System.getenv(\"PORT\");\r\n                if (port == null)\r\n                    port = JOptionPane.showInputDialog(frmWin, \"Enter Server PORT Number:\", SERVER_DEFAULT_PORT);\r\n\r\n                if (port == null) // check if Cancel button was pressed\r\n                    serverPort = -1;\r\n                else\r\n                    serverPort = Integer.parseInt(port);\r\n            }\r\n\r\n            // Setup Server Socket ...\r\n            serverSocket = new MyServerSocket(serverPort);\r\n\r\n            serverSetupOK = true;\r\n        } catch (Exception exp) {\r\n            serverSetupOK = false;\r\n            String serverAddress = serverIP + \":\" + serverPort;\r\n            log(\"Can't setup Server Socket on \" + serverAddress + \"\\n\" + \"Fix the problem & restart the server.\", exp, frmWin);\r\n        }\r\n\r\n        System.out.println(\"**** setupServer() finished! ****\");\r\n    }\r\n\r\n\r\n    private void exitServer() {\r\n        closeServer(\"\");\r\n    }\r\n\r\n    /**\r\n     * Log.\r\n     *\r\n     * @param msg the msg\r\n     */\r\n    public void log(String msg) {\r\n        msg = StrUtils.format(msg);\r\n        areaLog.append(msg + \"\\n\");\r\n        areaLog.setCaretPosition(areaLog.getDocument().getLength());\r\n        System.out.println(msg);\r\n    }\r\n\r\n    /**\r\n     * Synced list updated.\r\n     *\r\n     * @param list the list\r\n     */\r\n    public void syncedListUpdated(SyncedItems<?> list) {\r\n        list = prepareListForSend(list);\r\n        if (list.isEmpty())\r\n            return;\r\n        SyncedItems<?> finalList = list;\r\n        players.forEachItem(playerNet -> playerNet.getSocketToClient().writeMessage(Message.syncLists(finalList)));\r\n    }\r\n\r\n    /**\r\n     * Log.\r\n     *\r\n     * @param msg the msg\r\n     * @param ex  the ex\r\n     * @param win the win\r\n     */\r\n    public static void log(String msg, Exception ex, JFrame... win) {\r\n        String title = \"Runtime Exception: \" + msg;\r\n\r\n        System.out.println(\"\\n>> \" + title);\r\n        System.out.println(\">> \" + new String(new char[title.length()]).replace('\\0', '-'));\r\n\r\n        String errMsg = \">> \" + ex.toString() + \"\\n\";\r\n        for (StackTraceElement element : ex.getStackTrace())\r\n            errMsg += \">>> \" + element + \"\\n\";\r\n        System.out.println(errMsg);\r\n\r\n        if (win.length != 0) {\r\n            // bring the window into front (DeIconified)\r\n            win[0].setVisible(true);\r\n            win[0].toFront();\r\n            win[0].setState(JFrame.NORMAL);\r\n\r\n            // popup dialog with the error message\r\n            JOptionPane.showMessageDialog(win[0], msg + \"\\n\\n\" + errMsg, \"Exception Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n\r\n    private void closeServer(String cause) {\r\n        players.forEachItem(player -> {\r\n            ErrorHandler.ignore(() -> {\r\n                player.disconnect(cause);\r\n            });\r\n        });\r\n\r\n        if (serverSocket != null && !serverSocket.isClosed()) {\r\n            ErrorHandler.ignore(() -> {\r\n                serverSocket.close();\r\n            });\r\n        }\r\n\r\n        log(\"Server Closed! \" + cause);\r\n        serverRunOK = false;\r\n        SwingUtilities.invokeLater(() -> {\r\n            frmWin.setVisible(false);\r\n            frmWin.dispose(); // close GUI\r\n        });\r\n\r\n//        \uD83D\uDE28\r\n//        ThreadsManager.stopAll();\r\n    }\r\n\r\n    //todo move to synceditems as a func\r\n    private SyncedItems<?> prepareListForSend(SyncedItems<?> list) {\r\n        SyncedItems<?> ret = new SyncedItems<>(list.syncedListType);\r\n        ret.addAll(list.stream().map(SyncableItem::getSyncableItem).collect(Collectors.toList()));\r\n        return ret.clean();\r\n    }\r\n\r\n\r\n    /**\r\n     * The entry point of the application.\r\n     *\r\n     * @param args the input arguments\r\n     */\r\n// main\r\n    public static void main(String[] args) {\r\n        ArgsUtil util = ArgsUtil.create(args);\r\n\r\n        START_AT_PORT = util.equalsSign(\"p\").getInt(-1);\r\n        Minimax.SHOW_UI = util.plainTextIgnoreCase(\"DEBUG_MINIMAX\").exists();\r\n        \r\n        Server server = new Server();\r\n        server.runServer();\r\n\r\n        System.out.println(\"**** ChatServer main() finished! ****\");\r\n    }\r\n\r\n    private void sendAllSyncedLists(PlayerNet player, SyncedItems<?>... excludeLists) {\r\n        ArrayList<SyncedItems<?>> lists = new ArrayList<>();\r\n        for (SyncedItems<?> syncedList : syncedLists) {\r\n            if (Arrays.stream(excludeLists).noneMatch(excludedList -> excludedList.equals(syncedList)))\r\n                lists.add(prepareListForSend(syncedList));\r\n        }\r\n        player.getSocketToClient().writeMessage(Message.syncLists(lists.toArray(new SyncedItems[0])));\r\n    }\r\n\r\n    /**\r\n     * Run server.\r\n     */\r\n// Run the server - wait for clients to connect & handle them\r\n    public void runServer() {\r\n        ThreadsManager.HandledThread.runInHandledThread(() -> {\r\n            if (serverSetupOK) {\r\n                String serverAddress = \"(\" + serverIP + \":\" + serverPort + \")\";\r\n                log(\"SERVER\" + serverAddress + \" Setup & Running!\");\r\n//            log(new NoThrow<String>(DB::getAllUsersCredentials).get());\r\n                frmWin.setTitle(SERVER_WIN_TITLE + \" \" + serverAddress);\r\n\r\n                serverRunOK = true;\r\n\r\n                // loop while server running OK\r\n                while (serverRunOK) {\r\n                    AppSocket appSocketToPlayer = serverSocket.acceptAppSocket();\r\n                    if (appSocketToPlayer == null)\r\n                        serverRunOK = false;\r\n                    else {\r\n                        handleClient(appSocketToPlayer);\r\n                    }\r\n                }\r\n                closeServer(\"runServer() finised!\");\r\n            } else {\r\n                closeServer(\"server setup was not ok\");\r\n            }\r\n            System.out.println(\"**** runServer() finished! ****\");\r\n        });\r\n\r\n\r\n    }\r\n\r\n    // handle client in a separate thread\r\n    private void handleClient(AppSocket playerSocket) {\r\n        ThreadsManager.HandledThread.runInHandledThread(() -> {\r\n            ServerMessagesHandler messagesHandler = new ServerMessagesHandler(this, playerSocket);\r\n            playerSocket.setMessagesHandler(messagesHandler);\r\n            playerSocket.start();\r\n            PlayerNet player = login(playerSocket);\r\n            if (player == null) {\r\n                playerSocket.stopReading();\r\n                return;\r\n            }\r\n\r\n            messagesHandler.setPlayer(player);\r\n            players.add(player);\r\n\r\n            sendAllSyncedLists(player, players);\r\n\r\n            log(\"Client(\" + playerSocket.getRemoteAddress() + \") Connected as \" + player.getLoginInfo().getUsername());\r\n\r\n            gameSetup(player);\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Login player net.\r\n     *\r\n     * @param appSocket the app socket\r\n     * @return the player net\r\n     */\r\n    public PlayerNet login(AppSocket appSocket) {\r\n        Message request = appSocket.requestMessage(Message.askForLogin());\r\n        Message responseMessage = responseToLogin(request.getLoginInfo());\r\n        if (responseMessage == null)\r\n            return null;\r\n        while (responseMessage.getMessageType() == MessageType.ERROR) {\r\n\r\n            responseMessage.setRespondingTo(request);\r\n            request = appSocket.requestMessage(responseMessage);\r\n\r\n            responseMessage = responseToLogin(request.getLoginInfo());\r\n\r\n            if (responseMessage == null)\r\n                return null;\r\n        }\r\n\r\n        appSocket.respond(responseMessage, request);\r\n\r\n        LoginInfo loginInfo = request.getLoginInfo();\r\n\r\n        if (loginInfo.getLoginType() == LoginType.CANCEL)\r\n            return null;\r\n\r\n        if (responseMessage.getMessageType() != MessageType.ERROR) {\r\n            return new PlayerNet(appSocket, loginInfo);\r\n        }\r\n        return login(appSocket);\r\n    }\r\n\r\n    private Message responseToLogin(LoginInfo loginInfo) {\r\n        if (loginInfo == null)\r\n            return null;\r\n        String username = loginInfo.getUsername();\r\n        String password = loginInfo.getPassword();\r\n\r\n        return switch (loginInfo.getLoginType()) {\r\n            case LOGIN -> {\r\n                if (DB.isUserExists(username, password)) {\r\n                    if (!isLoggedIn(username)) {\r\n                        loginInfo.setProfilePic(DB.getProfilePic(username));\r\n                        yield Message.welcomeMessage(\"Welcome \" + username, loginInfo);\r\n                    } else {\r\n                        yield Message.error(\"User already connected\");\r\n                    }\r\n                } else {\r\n                    yield Message.error(\"Wrong username or password\");\r\n                }\r\n            }\r\n            case GUEST -> {\r\n                loginInfo.setUsername(RegEx.Prefixes.GUEST_PREFIX + \"#\" + autoChatterID++);\r\n                yield Message.welcomeMessage(\"Welcome \" + loginInfo.getUsername(), loginInfo);\r\n            }\r\n            case CANCEL -> Message.bye(\"\");\r\n            case REGISTER -> {\r\n                if (DB.isUsernameExists(username)) {\r\n                    yield Message.error(\"Username Exists Already\");\r\n                } else {\r\n                    DB.addUser(username, password);\r\n                    yield Message.welcomeMessage(\"Welcome \" + username, loginInfo);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private boolean isLoggedIn(String username) {\r\n        return players.stream().anyMatch(p -> p.getUsername().equals(username));\r\n    }\r\n\r\n    /**\r\n     * End of game session.\r\n     *\r\n     * @param session the session\r\n     */\r\n    public void endOfGameSession(GameSession session) {\r\n        gameSessions.remove(session.gameID, session);\r\n        (session.getPlayers()).stream().parallel().forEach(player -> {\r\n            if (player.isConnected()) {\r\n                gameSetup(player);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Game setup.\r\n     *\r\n     * @param player the player\r\n     */\r\n    public void gameSetup(Player player) {\r\n\r\n        SyncedItems<GameInfo> joinable = getJoinableGames(player);\r\n        SyncedItems<GameInfo> resumable = getResumableGames(player);\r\n\r\n        GameSettings gameSettings = null;\r\n        try {\r\n            gameSettings = player.getGameSettings(joinable, resumable);\r\n        } catch (MyError.DisconnectedError e) {\r\n        }\r\n        if (gameSettings == null) {\r\n            playerDisconnected(player, \"\");\r\n            return;\r\n        }\r\n//        if (gameSettings == null) {\r\n//            playerDisconnected(player);\r\n//            return;\r\n//        }\r\n        switch (gameSettings.getGameType()) {\r\n            case CREATE_NEW -> {\r\n                if (gameSettings.isVsAi()) {\r\n                    startGameVsAi(player, gameSettings);\r\n                } else {\r\n                    String id = gameIDGenerator.generate();\r\n                    CreatedGame gameInfo = new CreatedGame(id, player.getUsername(), gameSettings);\r\n                    gamePool.put(id, gameInfo);\r\n                    player.waitForMatch();\r\n                }\r\n            }\r\n            case JOIN_EXISTING -> {\r\n                GameInfo gameInfo = gamePool.get(gameSettings.getGameID());\r\n                if (gameInfo == null) {\r\n//                    throw new Error(\"user should get an error\");\r\n                    player.error(\"game does not exist\");\r\n                } else {\r\n                    GameSession gameSession = new GameSession(gameInfo, getPlayerNet(gameInfo.creatorUsername), player, this);\r\n                    gameSession.start();\r\n                    gameSessions.add(gameSession);\r\n                    gamePool.remove(gameSettings.getGameID());\r\n                }\r\n            }\r\n            case RESUME -> {\r\n                startGameVsAi(player, gameSettings);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets joinable games.\r\n     *\r\n     * @param player the player net\r\n     * @return the joinable games\r\n     */\r\n    public SyncedItems<GameInfo> getJoinableGames(Player player) {\r\n\r\n        return gamePool.clean();\r\n    }\r\n\r\n    /**\r\n     * Gets resumable games.\r\n     *\r\n     * @param player the player\r\n     * @return the resumable games\r\n     */\r\n    public SyncedItems<GameInfo> getResumableGames(Player player) {\r\n        return DB.getUnfinishedGames(player.getUsername()).clean();\r\n    }\r\n\r\n    /**\r\n     * Player disconnected.\r\n     *\r\n     * @param player the player\r\n     */\r\n    public void playerDisconnected(Player player, String message) {\r\n        if (player == null)\r\n            return;\r\n\r\n        log(player.getUsername() + \" disconnected\");\r\n        player.disconnect(message);\r\n\r\n//        Game ongoingGame = player.getOnGoingGame();\r\n//        if (ongoingGame != null) {\r\n//            ongoingGame.playerDisconnected(player);\r\n//        }\r\n\r\n        players.remove(player.getUsername());\r\n        List<GameInfo> del = gamePool.values()\r\n                .stream()\r\n                .filter(game -> game.creatorUsername.equals(player.getUsername()))\r\n                .toList();\r\n        del.forEach(deleting -> gamePool.remove(deleting.gameId));\r\n    }\r\n\r\n    private void startGameVsAi(Player player, GameSettings gameSettings) {\r\n        GameSession gameSession;\r\n        if (gameSettings.getGameType() == GameSettings.GameType.CREATE_NEW) {\r\n            PlayerAI ai = PlayerAI.createPlayerAi(gameSettings.getAiParameters());\r\n            gameSession = new GameSession(gameIDGenerator.generate(), player, ai, gameSettings, this);\r\n        } else {\r\n            String resumingId = gameSettings.getGameID();\r\n            UnfinishedGame resumingGame = DB.loadUnfinishedGame(resumingId);\r\n            DB.deleteUnfinishedGame(resumingGame);\r\n            PlayerAI ai = PlayerAI.createPlayerAi(resumingGame.gameSettings.getAiParameters());\r\n            gameSession = new GameSession(resumingGame, player, ai, this);\r\n        }\r\n        gameSessions.add(gameSession);\r\n        gameSession.start();\r\n    }\r\n\r\n    private PlayerNet getPlayerNet(String username) {\r\n        return players.stream()\r\n                .filter(p -> (p).getUsername().equals(username))\r\n                .findAny()\r\n                .orElse(null);\r\n    }\r\n\r\n    /**\r\n     * Create username suggestions array list.\r\n     *\r\n     * @param username the username\r\n     * @return the array list\r\n     */\r\n    public ArrayList<String> createUsernameSuggestions(String username) {\r\n\r\n        return UsernameSuggestions.createSuggestions(username);\r\n    }\r\n\r\n    /**\r\n     * Context type my error . context type.\r\n     *\r\n     * @return the my error . context type\r\n     */\r\n    @Override\r\n    public ContextType contextType() {\r\n        return null;\r\n//        return MyError.ContextType.Server;\r\n    }\r\n\r\n    /**\r\n     * Handled err.\r\n     *\r\n     * @param err the err\r\n     */\r\n    @Override\r\n    public void handledErr(MyError err) {\r\n        log(\"handled: \" + err.getHandledStr());\r\n\r\n    }\r\n\r\n    /**\r\n     * Critical err.\r\n     *\r\n     * @param err the err\r\n     */\r\n    @Override\r\n    public void criticalErr(MyError err) {\r\n        closeServer(\"critical error: \" + err);\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ver14/Server.java b/src/ver14/Server.java
--- a/src/ver14/Server.java	
+++ b/src/ver14/Server.java	
@@ -299,7 +299,7 @@
 
         START_AT_PORT = util.equalsSign("p").getInt(-1);
         Minimax.SHOW_UI = util.plainTextIgnoreCase("DEBUG_MINIMAX").exists();
-        
+
         Server server = new Server();
         server.runServer();
 
@@ -599,7 +599,7 @@
      * @return the my error . context type
      */
     @Override
-    public ContextType contextType() {
+    public Context contextType() {
         return null;
 //        return MyError.ContextType.Server;
     }
